<?xml version="1.0" encoding="ASCII"?>
<SoftwareMetricsMetamodel2:SMMModel xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:SoftwareMetricsMetamodel2="http://www.omg.org/ADM/SMM2" xmi:id="_Na8Y4OduEd6n-K6GP1KtgQ" metaModelPackageURI="http://www.eclipse.org/emf/2002/Ecore">
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:SMMCategory" xmi:id="_Na8Y4eduEd6n-K6GP1KtgQ" name="rules" measureElement="_Na8Y4uduEd6n-K6GP1KtgQ _Na8Y5eduEd6n-K6GP1KtgQ _Na8Y5uduEd6n-K6GP1KtgQ _Na8Y6eduEd6n-K6GP1KtgQ _Na8Y6uduEd6n-K6GP1KtgQ _Na8Y7OduEd6n-K6GP1KtgQ _Na8Y7eduEd6n-K6GP1KtgQ _Na8Y7uduEd6n-K6GP1KtgQ _Na8Y7-duEd6n-K6GP1KtgQ _Na8Y8eduEd6n-K6GP1KtgQ _Na8Y8uduEd6n-K6GP1KtgQ _Na8Y8-duEd6n-K6GP1KtgQ _Na8Y9eduEd6n-K6GP1KtgQ _Na8Y9uduEd6n-K6GP1KtgQ _Na8Y-OduEd6n-K6GP1KtgQ _Na8Y-eduEd6n-K6GP1KtgQ _Na8Y_OduEd6n-K6GP1KtgQ _Na8Y_eduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:DirectMeasure" xmi:id="_Na8Y4uduEd6n-K6GP1KtgQ" name="NumberOfContainedElements" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" directInvoke="true" trait="_Na8Y5OduEd6n-K6GP1KtgQ" upperThreshold="2.0" operation="self.eAllContainments->collect(c | Tuple {scope = self, nameFragments = Sequence { 'NoOf', c.name.upperFirst(), self.name.upperFirst() }, operationFragments = Sequence {'self.', c.name , '->size()'}})"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:Scope" xmi:id="_Na8Y4-duEd6n-K6GP1KtgQ" name="EClassScope" class="EClass" recognizer="delete"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:Characteristic" xmi:id="_Na8Y5OduEd6n-K6GP1KtgQ" name="delete"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:Counting" xmi:id="_Na8Y5eduEd6n-K6GP1KtgQ" name="BasePartioningBooleanProperty" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" trait="_Na8Y5OduEd6n-K6GP1KtgQ" upperThreshold="2.0" operation="self.eAttributes->select(a | a.eType.name = 'EBoolean')->collect(ba | Tuple {scope  = self, nameFragments = Sequence{'Is', ba.name.upperFirst(), self.name.upperFirst()}, operationFragments = Sequence{'self.', ba.name , ' = true'}})"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:CollectiveMeasure" xmi:id="_Na8Y5uduEd6n-K6GP1KtgQ" name="PartioningBooleanProperty" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" directInvoke="true" trait="_Na8Y5-duEd6n-K6GP1KtgQ" upperThreshold="2.0" accumulator="sum" baseMeasure="_Na8Y5eduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:Characteristic" xmi:id="_Na8Y5-duEd6n-K6GP1KtgQ" name="sum delete"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:MeasureAggregation" xmi:id="_Na8Y6OduEd6n-K6GP1KtgQ" name="base" from="_Na8Y5uduEd6n-K6GP1KtgQ" to="_Na8Y5eduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:Counting" xmi:id="_Na8Y6eduEd6n-K6GP1KtgQ" name="BaseReferentialOptionality" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" trait="_Na8Y5OduEd6n-K6GP1KtgQ" upperThreshold="2.0" operation="self.eReferences->select(r | r.lowerBound = 0)->collect(rl | Tuple {scope  = self,  nameFragments = Sequence{'Is', self.name.upperFirst(), 'Without', rl.name.upperFirst()}, operationFragments = Sequence{'self.', rl.name, '->size() = 0'}})"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:CollectiveMeasure" xmi:id="_Na8Y6uduEd6n-K6GP1KtgQ" name="ReferentialOptionality" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" directInvoke="true" trait="_Na8Y5-duEd6n-K6GP1KtgQ" upperThreshold="2.0" accumulator="sum" baseMeasure="_Na8Y6eduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:MeasureAggregation" xmi:id="_Na8Y6-duEd6n-K6GP1KtgQ" name="base" from="_Na8Y6uduEd6n-K6GP1KtgQ" to="_Na8Y6eduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:DirectMeasure" xmi:id="_Na8Y7OduEd6n-K6GP1KtgQ" name="DepthInInstanceTree" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" directInvoke="true" trait="_Na8Y5OduEd6n-K6GP1KtgQ" upperThreshold="2.0" operation="self.eAllReferences->select(r | r.eOpposite->notEmpty()  and (r.eType.name = self.name or r.eType.oclAsType(EClass).eAllSuperTypes->exists(r2 | r2.name = self.name)))->collect(r3 | Tuple { measure = Tuple { scope = self, nameFragments = Sequence{'DepthIn', self.name.upperFirst() , 'Tree'}, operationFragments = Sequence{'self.', r3.eOpposite.name, 'Depth()'}}, helpers = Sequence {'context ', self.name , ' def: ', r3.eOpposite.name, 'Depth(): Integer = if self.', r3.eOpposite.name, '->isEmpty() then 0 else maxValue(self.', r3.eOpposite.name, '->collect(p | p.', r3.eOpposite.name, 'Depth())) + 1 endif'}})"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:DirectMeasure" xmi:id="_Na8Y7eduEd6n-K6GP1KtgQ" name="NumberChildrenIinstance" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" directInvoke="true" trait="_Na8Y5OduEd6n-K6GP1KtgQ" upperThreshold="2.0" operation="self.eAllReferences->select(r | r.eType.name = self.name or r.eType.oclAsType(EClass).eAllSuperTypes->exists(r2 | r2.name = self.name))->collect(r3 | Tuple { scope = self, nameFragments = Sequence{'NoOfChildren', self.name.upperFirst()}, operationFragments = Sequence{'self.', r3.name, '->size()'}})"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:Counting" xmi:id="_Na8Y7uduEd6n-K6GP1KtgQ" name="BaseExistenceDependency" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" trait="_Na8Y5OduEd6n-K6GP1KtgQ" upperThreshold="2.0" operation="self.eReferences->select(r1 | r1.lowerBound > 0)->collect(r2 | Tuple { scope  = self, nameFragments = Sequence {self.name.upperFirst() ,'Minimal', r2.name.upperFirst()}, operationFragments = Sequence{'self.', r2.name , '->size() = ', r2.lowerBound.oclAsType(String)}})"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:CollectiveMeasure" xmi:id="_Na8Y7-duEd6n-K6GP1KtgQ" name="ExistenceDependency" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" directInvoke="true" trait="_Na8Y5-duEd6n-K6GP1KtgQ" upperThreshold="2.0" accumulator="sum" baseMeasure="_Na8Y7uduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:MeasureAggregation" xmi:id="_Na8Y8OduEd6n-K6GP1KtgQ" name="base" from="_Na8Y7-duEd6n-K6GP1KtgQ" to="_Na8Y7uduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:DirectMeasure" xmi:id="_Na8Y8eduEd6n-K6GP1KtgQ" name="InstanceUsageRatio" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y--duEd6n-K6GP1KtgQ" directInvoke="true" trait="_Na8Y5OduEd6n-K6GP1KtgQ" upperThreshold="2.0" operation="self.eClassifiers->select(e | e.oclIsKindOf(EClass))->reject(e | e.oclAsType(EClass).eSuperTypes->isEmpty())->collect(c1 | c1.oclAsType(EClass).eSuperTypes->collect(c2 | Tuple { scope  = self,  nameFragments = Sequence {'RatioOf', c1.oclAsType(EClass).name.upperFirst(), 'To', c2.oclAsType(EClass).name.upperFirst()}, operationFragments = Sequence {c1.oclAsType(EClass).name, '.allInstances()->size() / ', c2.oclAsType(EClass).name, '.allInstances()->size()'}})) "/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:DirectMeasure" xmi:id="_Na8Y8uduEd6n-K6GP1KtgQ" name="SizeMultiplicityManyReferences" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" trait="_Na8Y5OduEd6n-K6GP1KtgQ" upperThreshold="2.0" operation="self.eReferences->select(r | r.upperBound > 1 or r.upperBound = -1)->collect(mr | Tuple {scope = mr.eContainer(), nameFragments = Sequence {'NoOf', mr.name.upperFirst() , self.name.upperFirst()}, operationFragments = Sequence {'self.', mr.name, '->size()'}})"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:CollectiveMeasure" xmi:id="_Na8Y8-duEd6n-K6GP1KtgQ" name="AggregationAssociatedElementsSum" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" directInvoke="true" trait="_Na8Y5-duEd6n-K6GP1KtgQ" upperThreshold="2.0" accumulator="sum" baseMeasure="_Na8Y8uduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:MeasureAggregation" xmi:id="_Na8Y9OduEd6n-K6GP1KtgQ" name="base" from="_Na8Y8-duEd6n-K6GP1KtgQ" to="_Na8Y8uduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:DirectMeasure" xmi:id="_Na8Y9eduEd6n-K6GP1KtgQ" name="NumericPropertyValue" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" trait="_Na8Y5OduEd6n-K6GP1KtgQ" upperThreshold="2.0" operation="self.eAttributes->select(a | a.eType.name = 'EInt' or a.eType.name = 'EReal')->collect(na | Tuple {scope = self, nameFragments = Sequence{na.name.upperFirst(), self.name.upperFirst()}, operationFragments = Sequence{'self.', na.name}})"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:CollectiveMeasure" xmi:id="_Na8Y9uduEd6n-K6GP1KtgQ" name="AggregationNumericPropertyMax" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" directInvoke="true" trait="_Na8Y5-duEd6n-K6GP1KtgQ" upperThreshold="2.0" accumulator="sum" baseMeasure="_Na8Y9eduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:MeasureAggregation" xmi:id="_Na8Y9-duEd6n-K6GP1KtgQ" name="base" from="_Na8Y9uduEd6n-K6GP1KtgQ" to="_Na8Y9eduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:Counting" xmi:id="_Na8Y-OduEd6n-K6GP1KtgQ" name="BasePartioningEnumerationProperty" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" trait="_Na8Y5OduEd6n-K6GP1KtgQ" upperThreshold="2.0" operation="self.eAttributes->select(a | a.eType.oclIsKindOf(EEnum))->collect(a | a.eType.oclAsType(EEnum).eLiterals->collect(l | Tuple {scope = self, nameFragments = Sequence {'Is', a.eType.oclAsType(EEnum).getEEnumLiteral(l.value).literal.upperFirst(), self.name.upperFirst()}, operationFragments =Sequence{ 'self.', a.name, ' = ',a.eType.name, '::', a.eType.oclAsType(EEnum).getEEnumLiteral(l.value).literal}}))"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:CollectiveMeasure" xmi:id="_Na8Y-eduEd6n-K6GP1KtgQ" name="PartitioningEnumerationProperty" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" directInvoke="true" trait="_Na8Y5-duEd6n-K6GP1KtgQ" upperThreshold="2.0" accumulator="sum" baseMeasure="_Na8Y-OduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:MeasureAggregation" xmi:id="_Na8Y-uduEd6n-K6GP1KtgQ" name="base" from="_Na8Y-eduEd6n-K6GP1KtgQ" to="_Na8Y-OduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:Scope" xmi:id="_Na8Y--duEd6n-K6GP1KtgQ" name="EPackageScope" class="EPackage" recognizer="delete"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:Counting" xmi:id="_Na8Y_OduEd6n-K6GP1KtgQ" name="BasePartitioningSubclasses" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y4-duEd6n-K6GP1KtgQ" trait="_Na8Y5OduEd6n-K6GP1KtgQ" upperThreshold="2.0" operation="self.eSuperTypes->collect(c | Tuple { scope = self,  nameFragments = Sequence {'IsInstanceOf', self.name.upperFirst()}, operationFragments = Sequence {'self.oclIsTypeOf(', self.name, ')'}})"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:CollectiveMeasure" xmi:id="_Na8Y_eduEd6n-K6GP1KtgQ" name="PartitioningSubclasses" category="_Na8Y4eduEd6n-K6GP1KtgQ" scope="_Na8Y_uduEd6n-K6GP1KtgQ" directInvoke="true" trait="_Na8Y5-duEd6n-K6GP1KtgQ" upperThreshold="2.0" accumulator="sum" baseMeasure="_Na8Y_OduEd6n-K6GP1KtgQ"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:Scope" xmi:id="_Na8Y_uduEd6n-K6GP1KtgQ" name="EClassScope" class="EClass" recognizer="delete&#x9;"/>
  <sMMElement xsi:type="SoftwareMetricsMetamodel2:MeasureAggregation" xmi:id="_Na8Y_-duEd6n-K6GP1KtgQ" name="base" from="_Na8Y_eduEd6n-K6GP1KtgQ" to="_Na8Y_OduEd6n-K6GP1KtgQ"/>
</SoftwareMetricsMetamodel2:SMMModel>
